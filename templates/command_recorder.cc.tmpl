{{/*
 * Copyright (C) 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */}}




{{/*
  List of Vulkan objects that will be wrapped
  Each object should be defined in WrappedObjectTypes
*/}}
{{define "WrappedObjects"}}
VkCommandBuffer
{{end}}


{{/*
  List of functions normally instrumented
*/}}
{{define "DefaultInstrumentedFunctions"}}
vkCmdDispatch
vkCmdDispatchIndirect
vkCmdDraw
vkCmdDrawIndexed
vkCmdDrawIndirect
vkCmdDrawIndexedIndirect
vkCmdCopyBuffer
vkCmdCopyBufferToImage
vkCmdCopyImage
vkCmdCopyImageToBuffer
vkCmdBindPipeline
vkCmdExecuteCommands
vkCmdSetEvent
vkCmdResetEvent
vkCmdWaitEvents
vkCmdDebugMarkerBeginEXT
vkCmdDebugMarkerEndEXT
vkCmdDebugMarkerInsertEXT
vkCmdBeginDebugUtilsLabelEXT
vkCmdEndDebugUtilsLabelEXT
vkCmdInsertDebugUtilsLabelEXT
{{end}}


{{/*
  List of Vulkan types that can be named (from VkDebugReportObjectTypeEXT)
*/}}
{{define "NameVulkanObjects"}}
VkInstance
VkPhysicalDevice
VkDevice
VkQueue
VkSemaphore
VkCommandBuffer
VkFence
VkDeviceMemory
VkBuffer
VkImage
VkEvent
VkQueryPool
VkBufferView
VkImageView
VkShaderModule
VkPipelineCache
VkPipelineLayout
VkRenderPass
VkPipeline
VkDescriptorSetLayout
VkSampler
VkDescriptorPool
VkDescriptorSet
VkFramebuffer
VkCommandPool
VkSurfaceKHR
VkSwapchainKHR
VkDisplayKHR
VkDisplayModeKHR
VkDescriptorUpdateTemplate
VkSamplerYcbcrConversion
{{end}}


{{/* ---- Includes ---- */}}
{{Include "cpp_common.tmpl"}}
{{Include "layer.cc.tmpl"}}
{{Include "GFR.cc.tmpl"}}

{{/*
-------------------------------------------------------------------------------
Generate GFR command recorder
-------------------------------------------------------------------------------
*/}}
{{$ | Macro "GFR.CommandCommon" | Reflow 2 | Write "command_common.cc"}}
{{$ | Macro "GFR.CommandCommonHeader" | Reflow 2 | Write "command_common.h"}}
{{$ | Macro "GFR.CommandTracker" | Reflow 2 | Write "command_tracker.cc"}}
{{$ | Macro "GFR.CommandTrackerHeader" | Reflow 2 | Write "command_tracker.h"}}
{{$ | Macro "GFR.CommandRecorder" | Reflow 2 | Write "command_recorder.cc"}}
{{$ | Macro "GFR.CommandRecorderHeader" | Reflow 2 | Write "command_recorder.h"}}
{{$ | Macro "GFR.GFRHeaderInclude" | Reflow 2 | Write "gfr_commands.h.inc"}}
{{$ | Macro "GFR.GFRInclude" | Reflow 2 | Write "gfr_commands.cc.inc"}}
{{$ | Macro "GFR.CommandBufferHeaderInclude" | Reflow 2 | Write "command.h.inc"}}
{{$ | Macro "GFR.CommandBufferInclude" | Reflow 2 | Write "command.cc.inc"}}


{{/*
-------------------------------------------------------------------------------
  Emits a common source for command recording and tracking
-------------------------------------------------------------------------------
*/}}
{{define "GFR.CommandCommon"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
// clang-format off
#include "command_common.h"
¶
const char *Command::GetCommandName(const Command &cmd) {
  switch (cmd.type) {
  default:
  case Command::Type::kUnknown: return "Unknown";

  {{range $c := AllCommands $}}
    {{if (Macro "IsCommandBufferCommand" $c)}}
      case Command::Type::k{{Template "CmdNameNoVkNoCmd" $c}}: return "{{$c.Name}}";
    {{end}}
  {{end}}
  }
}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits a common header for command recording and tracking
-------------------------------------------------------------------------------
*/}}
{{define "GFR.CommandCommonHeader"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
// clang-format off
#ifndef COMMAND_COMMON_HEADER
#define COMMAND_COMMON_HEADER
¶
#include <cstring>
#include <iostream>
#include <vector>
#include <vulkan/vulkan.h>
¶
struct Command
{
  enum Type {
    kUnknown,
  {{range $c := AllCommands $}}
    {{if (Macro "IsCommandBufferCommand" $c)}}
      k{{Template "CmdNameNoVkNoCmd" $c}},
    {{end}}
  {{end}}
  };
¶
  public:
    static const char *GetCommandName(const Command &cmd);
¶
  Type type;
  uint32_t id;
  void *parameters;
};
#endif // COMMAND_COMMON_HEADER
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits CommandRecorder class
-------------------------------------------------------------------------------
*/}}
{{define "GFR.CommandRecorder"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
¶
// clang-format off
#include <iomanip>
#include <sstream>
¶
#include "command_recorder.h"
#include "object_name_db.h"
¶
auto constexpr kIndentDepth = 2;
¶
int NameIdx() {
  const static int name_idx = std::ios::xalloc();
  return name_idx;
}
¶
int IndentIdx() {
  const static int indent_idx = std::ios::xalloc();
  return indent_idx;
}
¶
std::ostream& NewEntry(std::ostream& os) {
  return os << "\n" << std::string(os.iword(IndentIdx()), ' ');
}
¶
std::ostream& OpenBracket(std::ostream& os) {
  os.iword(IndentIdx()) += kIndentDepth;
  return os;
}
¶
std::ostream& CloseBracket(std::ostream& os) {
  os.iword(IndentIdx()) -= kIndentDepth;
  return os;
}
¶
class IndentGuard {
 public:
  IndentGuard(std::ostream& stream, const int indentDepth = kIndentDepth) : stream_(stream), indentDepth_(indentDepth) {
    stream_.iword(IndentIdx()) += indentDepth_;
  }
  ~IndentGuard() { stream_.iword(IndentIdx()) -= indentDepth_; }
¶
 private:
  std::ostream& stream_;
  int indentDepth_;
};
¶
std::string GetObjectInfo(std::ostream& os, uint64_t h) {
  auto name_resolver = reinterpret_cast<ObjectInfoDB *>(os.pword(NameIdx()));
  assert(nullptr != name_resolver);

  std::stringstream ss;
  ss.iword(IndentIdx()) = os.iword(IndentIdx());
  ss << NewEntry;
  return name_resolver->GetObjectInfoNoHandleTag(h, ss.str());
}
¶
{{$namedObjects := Strings (Macro "NameVulkanObjects") | SplitEOL}}
{{range $o := $namedObjects}}
std::ostream& operator << (std::ostream& os, const {{$o}} &a) {
    os << GetObjectInfo(os, reinterpret_cast<uint64_t>(a));
    return os;
}
{{end}}
¶
void CommandRecorder::SetNameResolver(std::ostream &os, const ObjectInfoDB *name_resolver) {
  os.pword(NameIdx()) = (void *)name_resolver;
}
¶
{{Macro "DefineRecorderParameterPrinters" $}}
¶
{{Macro "DefineRecorderArrayCopies" $}}
{{range $c := AllCommands $}}
  {{if (Macro "IsCommandBufferCommand" $c)}}
    {{Template "DefineCommandPrint" $c}}
    ¶
  {{end}}
{{end}}
{{range $c := AllCommands $}}
  {{if (Macro "IsCommandBufferCommand" $c)}}
    {{Template "DefineParameterCapture" $c}}
    ¶
  {{end}}
{{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits CommandRecorder header
-------------------------------------------------------------------------------
*/}}
{{define "GFR.CommandRecorderHeader"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
// clang-format off
#ifndef COMMAND_RECORDER_HEADER
#define COMMAND_RECORDER_HEADER
¶
#include <cstring>
#include <iostream>
#include <vector>
#include <vulkan/vulkan.h>
¶
#include "linear_allocator.h"
#include "object_name_db.h"
¶
{{range $c := AllCommands $}}
  {{if (Macro "IsCommandBufferCommand" $c)}}
    {{Template "DefineCommandArgStruct" $c}}
    ¶
  {{end}}
{{end}}
¶
class CommandRecorder
{
public:
  void Reset() { m_allocator.Reset(); }
  void SetNameResolver(std::ostream &os, const ObjectInfoDB *name_resolver);
¶
  {{range $c := AllCommands $}}
    {{if (Macro "IsCommandBufferCommand" $c)}}
      {{Template "DeclareCommandPrint" $c}}
      {{Template "DeclareParameterCapture" $c}}
    {{end}}
  {{end}}
¶
private:
  template <typename T> T *Alloc() { return new(m_allocator.Alloc(sizeof(T))) T; }
  template <typename T> T *CopyArray(const T *src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<T *>(m_allocator.Alloc(sizeof(T) * count));
    std::memcpy(ptr, src, sizeof(T) * count);
    return ptr;
  }
¶
  LinearAllocator<> m_allocator;
};
#endif // COMMAND_RECORDER_HEADER
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits CommandTracker class that tracks commands and parameters
-------------------------------------------------------------------------------
*/}}
{{define "GFR.CommandTracker"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
¶
// clang-format off
#include <vulkan/vulkan.h>
#include <cassert>
¶
#include "command_common.h"
#include "command_tracker.h"
¶
void CommandTracker::Reset()
{
  commands_.clear();
  recorder_.Reset();
}
¶
void CommandTracker::SetNameResolver(std::ostream &os, const ObjectInfoDB *name_resolver)
{
  recorder_.SetNameResolver(os, name_resolver);
}
¶
void CommandTracker::PrintCommandParameters(std::ostream &os, const Command &cmd, const std::string& indent)
{
  switch (cmd.type)
  {
  case Command::Type::kUnknown:
    os << "";
    break;
  {{range $c := AllCommands $}}
    {{if (Macro "IsCommandBufferCommand" $c)}}
      case Command::Type::k{{Template "CmdNameNoVkNoCmd" $c}}:
        Print{{Template "CmdNameNoVk" $c}}(os, cmd, indent);
        break;
    {{end}}
  {{end}}
  };
}
¶
{{range $c := AllCommands $}}
  {{if (Macro "IsCommandBufferCommand" $c)}}
    {{Template "DefineCommandTracking" $c}}
    {{Template "DefineCommandTrackerPrintParameters" $c}}
  {{end}}
{{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits CommandTracker header file
-------------------------------------------------------------------------------
*/}}
{{define "GFR.CommandTrackerHeader"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
// clang-format off
#ifndef COMMAND_TRACKER_HEADER
#define COMMAND_TRACKER_HEADER
¶
#include <vector>
#include <iostream>
#include <vulkan/vulkan.h>
¶
#include "command_recorder.h"
¶
class CommandTracker
{
public:
  void Reset();
  void SetNameResolver(std::ostream &os, const class ObjectInfoDB *name_resolver);
  void PrintCommandParameters(std::ostream &os, const Command &cmd, const std::string& indent);
¶
  const std::vector<Command> &GetCommands() const { return commands_; }
  std::vector<Command> &GetCommands() { return commands_; }
¶
  {{range $c := AllCommands $}}
    {{if (Macro "IsCommandBufferCommand" $c)}}
      {{Template "DeclareCommandTracking" $c}}
    {{end}}
  {{end}}
¶
private:
  {{range $c := AllCommands $}}
    {{if (Macro "IsCommandBufferCommand" $c)}}
      {{Template "DeclareCommandTrackerPrintParameters" $c}}
    {{end}}
  {{end}}
¶
  std::vector<Command> commands_;
  CommandRecorder recorder_;
};
#endif // COMMAND_TRACKER_HEADER
{{end}}


{{/*
-------------------------------------------------------------------------------
  List of custom commands for the GFR, they will not be generated
-------------------------------------------------------------------------------
*/}}
{{define "CustomGfrCommands"}}
vkCmdBindPipeline
vkBeginCommandBuffer
vkResetCommandBuffer
{{end}}


{{/*
-------------------------------------------------------------------------------
  Returns true if the command will have a custom definition
-------------------------------------------------------------------------------
*/}}
{{define "IsCustomGfrCommand"}}
  {{AssertType $ "Function"}}
  {{$filters := Strings (Macro "CustomGfrCommands") | SplitEOL}}
  {{range $f := $filters}}
    {{if eq $.Name $f}}true{{end}}
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits an include file for GFR.h to handle command tracking
-------------------------------------------------------------------------------
*/}}
{{define "GFR.GFRHeaderInclude"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
// clang-format off
{{range $c := AllCommands $}}
  {{if (Macro "IsCommandBufferCommand" $c)}}
    {{Template "DeclareGfrInterceptFunction" $c}}
  {{end}}
{{end}}
// clang-format on
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits an include file for GFR.cc to handle command tracking
-------------------------------------------------------------------------------
*/}}
{{define "GFR.GFRInclude"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
// clang-format off
{{range $c := AllCommands $}}
  {{if (Macro "IsCommandBufferCommand" $c)}}
    {{if not (Macro "IsCustomGfrCommand" $c)}}
      {{Template "DefineGfrInterceptFunction" $c}}
    {{end}}
  {{end}}
{{end}}
// clang-format on
{{end}}


{{/*
-------------------------------------------------------------------------------
  List of custom functions for the CommandBuffer, they will not be generated
-------------------------------------------------------------------------------
*/}}
{{define "CustomCommandBufferFunctions"}}
vkBeginCommandBuffer
vkEndCommandBuffer
vkResetCommandBuffer
{{end}}


{{/*
-------------------------------------------------------------------------------
  Returns true if the command will have a custom
-------------------------------------------------------------------------------
*/}}
{{define "IsCustomCommandBufferCommand"}}
  {{AssertType $ "Function"}}
  {{$filters := Strings (Macro "CustomCommandBufferFunctions") | SplitEOL}}
  {{range $f := $filters}}
    {{if eq $.Name $f}}true{{end}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits an include file for command.h to handle command tracking
-------------------------------------------------------------------------------
*/}}
{{define "GFR.CommandBufferHeaderInclude"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
// clang-format off
{{range $c := AllCommands $}}
  {{if (Macro "IsCommandBufferCommand" $c)}}
    {{if not (Macro "IsCustomCommandBufferCommand" $c)}}
      {{Template "DeclareUnwrappedInterceptFunction" $c}}
    {{end}}
  {{end}}
{{end}}
// clang-format on
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits an include file for command.h to handle command tracking
-------------------------------------------------------------------------------
*/}}
{{define "GFR.CommandBufferInclude"}}
{{AssertType $ "API"}}
{{Template "C++.Copyright"}}
// clang-format off
{{range $c := AllCommands $}}
  {{if (Macro "IsCommandBufferCommand" $c)}}
    {{if not (Macro "IsCustomCommandBufferCommand" $c)}}
      {{Template "DefineCommandBufferInterceptFunction" $c}}
    {{end}}
  {{end}}
{{end}}
// clang-format on
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the name of the specified command with out the "vk" prefix
  "vkCmdDraw" -> "CmdDraw"
-------------------------------------------------------------------------------
*/}}
{{define "CmdNameNoVk"}}
  {{AssertType $ "Function"}}
  {{TrimPrefix "vk" (CommandName $) }}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the name of the specified command with out the "vk" and "Cmd" prefix
  "vkCmdDraw" -> "Draw"
-------------------------------------------------------------------------------
*/}}
{{define "CmdNameNoVkNoCmd"}}
  {{AssertType $ "Function"}}
  {{TrimPrefix "Cmd" (Macro "CmdNameNoVk" $) }}
{{end}}


{{/*
-------------------------------------------------------------------------------
  True if the command is a VkCommandBuffer command
-------------------------------------------------------------------------------
*/}}
{{define "IsCommandBufferCommand"}}
  {{AssertType $ "Function"}}
  {{$indirection := print Title (Macro "InitialIndirection" $)}}
  {{if eq $indirection "VkCommandBuffer"}}
    true
  {{end}}
{{end}}


{{define "ParameterAsMember"}}
  {{AssertType $ "Type" "Parameter"}}
  {{Template "C++.ParameterTypeNoSuffix" $}} {{$.Name}}{{Template "C++.StaticArraySuffix" $}};
{{end}}


{{define "DefineCommandArgStructName"}}
  {{AssertType $ "Function"}}
  {{Macro "CmdNameNoVk" $}}Args
{{end}}


{{define "DefineCommandArgStructParameter"}}
  {{AssertType $ "Function"}}
  , {{Macro "DefineCommandArgStructName" $}} *args
{{end}}


{{define "DefineCommandArgStruct"}}
  {{AssertType $ "Function"}}
  struct {{Template "DefineCommandArgStructName" $}} {
  {{ForEach $.CallParameters "ParameterAsMember" | JoinWith "\n"}}
  };
{{end}}


{{define "PrintCommandArg"}}
  // PrintCommandArg
  {{AssertType $ "Type" "Parameter"}}

  {{if IsPointer $.Type}}
    {{if IsChar $.Type.To}}
      os << "- # parameter:";
      os << OpenBracket << NewEntry;
      os << "name: " << "{{$.Name}}";
      os << NewEntry;
      os << "value: " << "\"" << args.{{$.Name}} << "\"";
      os << CloseBracket
    {{end}}
  {{else if IsStaticArray $.Type}}
    os << "- # parameter:";
    os << OpenBracket << NewEntry;
    os << "name: " << "{{$.Name}}";
    os << NewEntry;
    os << "values: [";
    for (uint32_t i = 0; i < {{Template "C++.StaticArraySize" $}}; ++i) {
        os << args.{{$.Name}}[i];
        if (i < {{Template "C++.StaticArraySize" $}} - 1) {
            os << ", ";
        }
        os << NewEntry;
    }
    os << "]";
    os << CloseBracket
  {{else}}
    os << "- # parameter:";
    os << OpenBracket << NewEntry;
    os << "name: " << "{{$.Name}}";
    os << NewEntry;
    os << "value: " << args.{{$.Name}};
    os << CloseBracket
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Reads a value from the API parameters to record the entire parameter set
-------------------------------------------------------------------------------
*/}}
{{define "PrintParameterValue"}}
  {{     if IsSliceIndex       $}}
    {{if not (IsMember $.Slice.Pointer)}}
      os << "- # parameter:";
      os << OpenBracket << NewEntry;
      os << "name: " << "{{Template "C++.Read" $.Slice.Pointer}}";
      os << NewEntry;
      os << "members:";
      os << *args.{{Template "C++.Read" $.Slice.Pointer}};
      os << CloseBracket << NewEntry;
    {{end}}
  {{else if IsPointerRange $}}{{if not (IsMember $.Pointer)}}if (args.{{Template "C++.Read" $.Pointer}}) {
      os << "- # parameter:";
      os << OpenBracket << NewEntry;
      os << "name: " << "{{Template "C++.Read" $.Pointer}}";
      os << NewEntry;
      os <<"members:";
      os << OpenBracket << NewEntry;
      if ((uint64_t)args.{{Macro "C++.ReadAsCallArgument" $.Range.RHS.Object}} > 0) {
        for (uint32_t i = {{Template "C++.Read" $.Range.LHS}}; i < (uint64_t)args.{{Macro "C++.ReadAsCallArgument" $.Range.RHS.Object}}; i++) {
          os << "- # {{$.Type.To}}";
          os << OpenBracket << NewEntry;
         {{if IsClass ($.Type.To | Underlying | Unpack)}}
            os << "members:";
          {{else}}
            os << "value: ";
          {{end}}
          os << args.{{Template "C++.Read" $.Pointer}}[i];
          os << CloseBracket;
          if (i < (uint64_t)args.{{Macro "C++.ReadAsCallArgument" $.Range.RHS.Object}} - 1) {
              os << NewEntry;
          }
        }
      }
      os << CloseBracket;
      os << CloseBracket << NewEntry;
  } else {
      os << "- # parameter:";
      os << OpenBracket << NewEntry;
      os << "name: " << "{{Template "C++.Read" $.Pointer}}";
      os << NewEntry;
      os << "value: nullptr";
      os << CloseBracket << NewEntry;
  }

  {{if eq (Global "RecursiveStatement") 1}}
  END_VALUE
  {{else}}
  os << ""
  {{end}}
  {{end}}
  {{else}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Macro to explore both branches in a branch statement.
-------------------------------------------------------------------------------
*/}}
{{define "FullBranch"}}
  {{AssertType $ "Branch"}}
  {{$gr := (Global "RecursiveStatement")}}
  {{Global "RecursiveStatement" 1}}

  {{Template "C++.Block" $.True}}
  {{if $.False}}
  {{Template "C++.Block" $.False}}
  {{end}}

  {{Global "RecursiveStatement" $gr}}
{{end}}


{{define "ParameterPrintStatementDebug"}}
  {{     if IsDeclareLocal $}}/*LOCAL*/{{Template "PrintParameterValue" $.Local.Value}}
  {{else if IsAbort        $}}/*ABORT*/
  {{else if IsAssign       $}}/*ASSIGN*/
  {{else if IsArrayAssign  $}}/*AASSIGN*/
  {{else if IsBlock        $}}/*BLOCK*/{¶{{Template "C++.Block" $}}¶}
  {{else if IsMapAssign    $}}/*MAPAS*/
  {{else if IsSliceAssign  $}}/*SLICEAS*/
  {{else if IsMapRemove    $}}/*MAPRM*/
  {{else if IsReturn       $}}/*RETURN*/
  {{else if IsBranch       $}}/*BRANCH*/{{Template "FullBranch" $}}
  {{else if IsSwitch       $}}/*SWITCH*/
  {{else if IsIteration    $}}/*ITER*/
  {{else if IsMapIteration $}}/*MAPITER*/
  {{else if IsCall         $}}/*CALL*/
  {{else if IsAssert       $}}/*ASSERT*/
  {{else if IsRead         $}}/*READ*/
  {{else if IsWrite        $}}/*WRITE*/
  {{else if IsCopy         $}}/*COPY*/
  {{else if IsFence        $}}/*FENCE*/
  {{else if IsMapClear     $}}/*MAPCL*/
  {{else                    }}{{Error "unsupported statement %T: %+v" $ $}}
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Override for the "C++.Statement" macro.

  We are only interested in local declarations as they are the ones that copy
  pointer values from the Vulkan parameters


-------------------------------------------------------------------------------
*/}}
{{define "ParameterPrintStatement"}}
  {{     if IsDeclareLocal $}}{{Template "PrintParameterValue" $.Local.Value}}
  {{else if IsAbort        $}}
  {{else if IsAssign       $}}
  {{else if IsArrayAssign  $}}
  {{else if IsBlock        $}}
    {{$gr := (Global "RecursiveStatement")}}
    {{Global "RecursiveStatement" 1}}
    {{Template "C++.Block" $}}
    {{Global "RecursiveStatement" $gr}}
  {{else if IsMapAssign    $}}
  {{else if IsSliceAssign  $}}
  {{else if IsMapRemove    $}}
  {{else if IsReturn       $}}
  {{else if IsBranch       $}}{{Template "FullBranch" $}}
  {{else if IsSwitch       $}}
  {{else if IsIteration    $}}
  {{else if IsMapIteration $}}
  {{else if IsCall         $}}
  {{else if IsAssert       $}}
  {{else if IsRead         $}}
  {{else if IsWrite        $}}
  {{else if IsCopy         $}}
  {{else if IsFence        $}}
  {{else if IsMapClear     $}}
  {{else                    }}{{Error "unsupported statement %T: %+v" $ $}}
  {{end}}
{{end}}


{{define "DeclareCommandPrint"}}
  {{AssertType $ "Function"}}
  void Print{{Macro "CmdNameNoVk" $}}Args(std::ostream &os, const {{Macro "CmdNameNoVk" $}}Args &args, const std::string& indent);
{{end}}


{{define "DefineCommandPrint"}}
  {{AssertType $ "Function"}}
  void CommandRecorder::Print{{Macro "CmdNameNoVk" $}}Args(std::ostream &os, const {{Macro "CmdNameNoVk" $}}Args &args, const std::string& indent)
  {
    IndentGuard param_indent(os, (int)indent.size() + 1);
    os << NewEntry;

    {{Global "RecursiveStatement" 0}}
    {{Global "C++.Statement.Override" "ParameterPrintStatement"}}
    {{$params := (ForEach $.CallParameters "PrintCommandArg")}}
    {{$stmnts := (ForEach $.Block.Statements "C++.Statement")}}
    {{$all := Join $params $stmnts}}
    {{Strings $all | Replace "END_VALUE" "os << \"\";\n" | JoinWith " << NewEntry;\n" }};
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the fixed-size-array value for static array parameter types.
-------------------------------------------------------------------------------
*/}}
{{define "C++.StaticArraySize"}}
  {{if not (IsType $)}}{{Template "C++.StaticArraySize" (TypeOf $)}}
  {{else if IsStaticArray $}}{{$.Size}}§
  {{end}}
{{end}}


{{define "CopyCommandArgArray"}}
  {{AssertType $ "Type" "Parameter"}}
  for (uint32_t i = 0; i < {{Template "C++.StaticArraySize" $}}; ++i) { args->{{$.Name}}[i] = {{$.Name}}[i]; }
{{end}}


{{define "CopyCommandArg"}}
  {{AssertType $ "Type" "Parameter"}}
  {{if (Macro "C++.StaticArraySuffix" $)}}{{Template "CopyCommandArgArray" $}}{{else}}args->{{$.Name}} = {{$.Name}};{{end}} // {{TypeOf $}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the type of read (for debugging templates)
-------------------------------------------------------------------------------
*/}}
{{define "ReadType"}}
  {{     if IsBoolValue        $}}[READ]bool
  {{else if IsNumericValue     $}}[READ]numeric
  {{else if IsStringValue      $}}[READ]string
  {{else if IsMessageValue     $}}[READ]message
  {{else if IsParameter        $}}[READ]parameter
  {{else if IsBinaryOp         $}}[READ]binaryOp
  {{else if IsUnaryOp          $}}[READ]unaryOp
  {{else if IsEnumEntry        $}}[READ]enum
  {{else if IsLocal            $}}[READ]local
  {{else if IsBitTest          $}}[READ]bittest
  {{else if IsBinaryOp         $}}[READ]binaryOp
  {{else if IsCast             $}}[READ]cast
  {{else if IsCall             $}}[READ]call
  {{else if IsUnknown          $}}[READ]unknown
  {{else if IsObserved         $}}[READ]observed
  {{else if IsMember           $}}[READ]member
  {{else if IsGlobal           $}}[READ]global
  {{else if IsArrayIndex       $}}[READ]arrayIndex
  {{else if IsMapIndex         $}}[READ]mapIndex
  {{else if IsMapContains      $}}[READ]mapContains
  {{else if IsLength           $}}[READ]length
  {{else if IsNull             $}}[READ]null
  {{else if IsNew              $}}[READ]new
  {{else if IsCreate           $}}[READ]create
  {{else if IsArrayInitializer $}}[READ]arrayInit
  {{else if IsClassInitializer $}}[READ]classInit
  {{else if IsSliceContains    $}}[READ]sliceContains
  {{else if IsSliceIndex       $}}[READ]sliceIndex
  {{else if IsSliceRange       $}}[READ]sliceRange
  {{else if IsPointerRange     $}}[READ]pointerRange
  {{else if IsClone            $}}[READ]clone
  {{else if IsMake             $}}[READ]make
  {{else if IsSelect           $}}[READ]select
  {{else if IsField            $}}[READ]field
  {{else if IsCallable         $}}[READ]callable
  {{else}}{{Error "macro C++.Read called with unsupported type: %T" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Reads a value from the API parameters to record the entire parameter set
-------------------------------------------------------------------------------
*/}}
{{define "CopyParameterValue"}}
  {{     if IsSliceIndex       $}}{{Template "CopyParameterValue" $.Slice}}
  {{else if IsPointerRange     $}}{{if not (IsMember $.Pointer)}}if ({{Template "C++.Read" $.Pointer}}) {
    args->{{Template "C++.Read" $.Pointer}} = CopyArray({{Template "C++.Read" $.Pointer}}, {{Template "C++.Read" $.Range.LHS}}, {{Template "C++.Read" $.Range.RHS}});
  }
  {{end}}
  {{else}}
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Override for the "C++.Statement" macro.

  We are only interested in local declarations as they are the ones that copy
  pointer values from the Vulkan parameters
-------------------------------------------------------------------------------
*/}}
{{define "ParameterCaptureStatement"}}
  {{     if IsDeclareLocal $}}{{Template "CopyParameterValue" $.Local.Value}}
  {{else if IsAbort        $}}
  {{else if IsAssign       $}}
  {{else if IsArrayAssign  $}}
  {{else if IsBlock        $}}
    {{$gr := (Global "RecursiveStatement")}}
    {{Global "RecursiveStatement" 1}}
    {{Template "C++.Block" $}}
    {{Global "RecursiveStatement" $gr}}
  {{else if IsMapAssign    $}}
  {{else if IsSliceAssign  $}}
  {{else if IsMapRemove    $}}
  {{else if IsReturn       $}}
  {{else if IsBranch       $}}{{Template "FullBranch" $}}
  {{else if IsSwitch       $}}
  {{else if IsIteration    $}}
  {{else if IsMapIteration $}}
  {{else if IsCall         $}}
  {{else if IsAssert       $}}
  {{else if IsRead         $}}
  {{else if IsWrite        $}}
  {{else if IsCopy         $}}
  {{else if IsFence        $}}
  {{else if IsMapClear     $}}
  {{else                    }}{{Error "unsupported statement %T: %+v" $ $}}
  {{end}}
{{end}}


{{define "DeclareParameterCapture"}}
  {{AssertType $ "Function"}}
  {{Macro "DefineCommandArgStructName" $}} *Record{{Macro "CmdNameNoVk" $}}({{Template "C++.CallParameters" $}});
{{end}}


{{define "DefineParameterCapture"}}
  {{AssertType $ "Function"}}
  {{Macro "DefineCommandArgStructName" $}} *CommandRecorder::Record{{Macro "CmdNameNoVk" $}}({{Template "C++.CallParameters" $}})
  {
    auto *args = Alloc<{{Macro "DefineCommandArgStructName" $}}>();
    {{ForEach $.CallParameters "CopyCommandArg" | JoinWith "\n"}}

    {{Global "RecursiveStatement" 0}}
    {{Global "C++.Statement.Override" "ParameterCaptureStatement"}}
    {{Template "C++.Block" $.Block}}
    return args;
  }
{{end}}


{{define "BaseType"}}
  {{if not (IsType $)}}{{Template "BaseType" (TypeOf $)}}
  {{else if IsVoid        $}}
  {{else if IsBool        $}}
  {{else if IsInt         $}}
  {{else if IsUint        $}}
  {{else if IsSize        $}}
  {{else if IsChar        $}}
  {{else if IsU8          $}}
  {{else if IsS8          $}}
  {{else if IsU16         $}}
  {{else if IsS16         $}}
  {{else if IsF32         $}}
  {{else if IsU32         $}}uint32_t
  {{else if IsS32         $}}
  {{else if IsF64         $}}
  {{else if IsU64         $}}
  {{else if IsS64         $}}
  {{else if IsEnum        $}}
  {{else if IsReference   $}}
  {{else if IsString      $}}
  {{else if IsStaticArray $}}
  {{else if IsSlice       $}}
  {{else if IsPointer     $}}{{Template "BaseType" $.To}}
  {{else if IsAny         $}}
  {{else}}{{Template "C++.TypeName" $}}
  {{end}}
{{end}}


{{define "TypeName"}}
  {{if not (IsType $)}}{{Template "TypeName" (TypeOf $)}}
  {{else if IsVoid        $}}void
  {{else if IsBool        $}}bool
  {{else if IsInt         $}}int
  {{else if IsUint        $}}uint
  {{else if IsSize        $}}size
  {{else if IsChar        $}}char
  {{else if IsU8          $}}u8
  {{else if IsS8          $}}uint8_t
  {{else if IsU16         $}}u16
  {{else if IsS16         $}}s16
  {{else if IsF32         $}}float
  {{else if IsU32         $}}uint32_t
  {{else if IsS32         $}}int32_t
  {{else if IsF64         $}}double
  {{else if IsU64         $}}uint64_t
  {{else if IsS64         $}}int64_t
  {{else if IsEnum        $}}enum
  {{else if IsReference   $}}ref
  {{else if IsString      $}}string
  {{else if IsStaticArray $}}staticArray
  {{else if IsSlice       $}}slice
  {{else if IsPointer     $}}ptr {{Template "TypeName" $.To}}
  {{else if IsAny         $}}any
  {{else}}{{Template "C++.TypeName" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Prints a struct's field
-------------------------------------------------------------------------------
*/}}
{{/* TODO(aellem) Share with PrintCommandArg if we can */}}
{{define "PrintField"}}
  // PrintField
  {{if IsPointer $.Type}}
    {{if IsChar $.Type.To}}
      os << "- # parameter:";
      os << OpenBracket << NewEntry;
      os << "name: " << ".{{$}}";
      os << NewEntry;
      os << "value: " << "\"" << a.{{$}} << "\"";
      os << CloseBracket
    {{else if not (IsVoid $.Type.To)}}
      if (a.{{$}}) {
        os << "- # parameter:";
        os << OpenBracket << NewEntry;
        os << "name: " << ".{{$}}";
        os << NewEntry;
        os << "value: " << *a.{{$}};
        os << CloseBracket;
      } else {
        os << "- # parameter:";
        os << OpenBracket << NewEntry;
        os << "name: " << ".{{$}}";
        os << NewEntry;
        os << "value: nullptr";
        os << CloseBracket;
      }
    {{else}}
      os << "- # parameter:";
      os << OpenBracket << NewEntry;
      os << "name: " << ".{{$}}";
      os << NewEntry;
      if (a.{{$}}) {
        os << "value: " << a.{{$}};
      } else {
        os << "value: nullptr";
      }
      os << CloseBracket
    {{end}}
  {{else if IsStaticArray $.Type}}
      os << "- # parameter:";
      os << OpenBracket << NewEntry;
      os << "name: " << ".{{$}}";
      os << NewEntry;
      os << "values: [";
      for (uint32_t i = 0; i < {{Template "C++.StaticArraySize" $}}; ++i) {
        os << a.{{$.Name}}[i];
        if (i < {{Template "C++.StaticArraySize" $}} - 1) {
         os << ", ";
        }
        os << NewEntry;
      }
      os << "]";
      os << CloseBracket
  {{else}}
    os << "- # parameter:";
    os << OpenBracket << NewEntry;
    os << "name: " << ".{{$}}";
    os << NewEntry;
    os << "value: " << a.{{$}};
    os << CloseBracket
  {{end}}
{{end}}


{{define "DefineRecorderParameterPrinter"}}
std::ostream& operator << (std::ostream& os, const {{$.Name}} &a)
{
  os << OpenBracket;
  os << NewEntry;
  {{ForEach $.Fields "PrintField" | JoinWith " << NewEntry;\n" }};
  os << CloseBracket; // Named Op
  return os;
}
{{end}}


{{define "DefineRecorderArrayCopy"}}
  template<>
  {{$}} *CommandRecorder::CopyArray<{{$}}>(const {{$}} *src, uint64_t start_index, uint64_t count)
  {
    auto ptr = reinterpret_cast<{{$}} *>(m_allocator.Alloc(sizeof({{$}}) * count));
    for (uint64_t i = 0; i < count; ++i) {
      {{range $f := $.Fields}}
        {{if IsPointer $f.Type}}
          {{if IsChar $f.Type.To}}
          ptr[i].{{$f.Name}} = nullptr;
          if (src[start_index + i].{{$f.Name}}) {
            ptr[i].{{$f.Name}} = CopyArray<>(src[start_index + i].{{$f.Name}}, 0, strlen(src[start_index + i].{{$f.Name}}));
          }
      {{else if not (IsVoid $f.Type.To)}}
          ptr[i].{{$f.Name}} = nullptr;
          if (src[start_index + i].{{$f.Name}}) {
            ptr[i].{{$f.Name}} = CopyArray<>(src[start_index + i].{{$f.Name}}, 0, 1); // {{Template "TypeName" $f.Type}} // todo: do we know count?
          }
          {{else}}
          ptr[i].{{$f.Name}} = src[start_index + i].{{$f.Name}}; // {{Template "TypeName" $f.Type}}
          {{end}}
        {{else if IsStaticArray $f.Type}}
          std::memcpy(ptr[i].{{$f.Name}}, src[start_index + i].{{$f.Name}}, sizeof(src[start_index + i].{{$f.Name}})); // {{Template "TypeName" $f.Type}}
        {{else}}
        ptr[i].{{$f.Name}} = src[start_index + i].{{$f.Name}}; // {{Template "TypeName" $f.Type}}
        {{end}}
      {{end}}
    }

    return ptr;
  }
{{end}}


{{define "IsVkFlags"}}
  {{if not (IsType $)}}{{Template "IsVkFlags" (TypeOf $)}}
  {{else if IsPseudonym $}}
    {{if eq (print $.To) "VkFlags"}}
    true
    {{end}}
  {{end}}
{{end}}


{{/*
  Gets all used non-basic parameter types used by vulkan commands.
  The list is returned in the "UniqueParameterTypes" global.
*/}}
{{define "GetUsedParameterTypes"}}
  {{AssertType $ "API"}}
  {{Global "ParameterTypes" ""}}
  {{Global "UniqueParameterTypes" ""}}

  {{/* Get a list of all parameter types */}}
  {{range $c := AllCommands $}}
    {{if (Macro "IsCommandBufferCommand" $c)}}
      {{range $p := $c.CallParameters}}
        {{if (IsPointer $p.Type)}}
          {{$pts := (Global "ParameterTypes")}}
          {{if (Macro "IsVkFlags" $p)}}
            {{Global "ParameterTypes" ("VkFlags" | Strings $pts | JoinWith "\n") }}
          {{else}}
            {{Global "ParameterTypes" (print (Macro "BaseType" $p) | Strings $pts | JoinWith "\n") }}
          {{end}}
        {{end}}
      {{end}}
    {{end}}
  {{end}}

  {{/* We now remove duplicates by setting a global var to 0 for each type and checking if it's non-zero before emitting */}}
  {{$all_types := (Global "ParameterTypes") | SplitEOL}}
  {{range $c := $all_types}}
    {{Global $c 0}}
  {{end}}

  {{range $t := $all_types}}
    {{if eq (Global $t) 0}}
      {{Global $t 1}}
      {{range $c := $.Classes}}
        {{if eq $c.Name $t}}
          {{$pts := (Global "UniqueParameterTypes")}}
          {{Global "UniqueParameterTypes" ($t | Strings $pts | JoinWith "\n")}}
        {{end}}
      {{end}}
    {{end}}
  {{end}}
{{end}}


{{/*
  Gets all used non-basic parameter types used by vulkan commands and used by
  their parameters.
  The list is returned in the "UniqueParameterTypes" global.
*/}}
{{define "GetUsedParameterTypesRecursive"}}
  {{AssertType $ "API"}}
  {{Global "ParameterTypes" ""}}
  {{Global "UniqueParameterTypes" ""}}

  {{/* Get a list of all parameter types */}}
  {{range $c := AllCommands $}}
    {{if (Macro "IsCommandBufferCommand" $c)}}
      {{range $p := $c.CallParameters}}
        {{if (IsPointer $p.Type)}}
          {{$pts := (Global "ParameterTypes")}}
          {{if (Macro "IsVkFlags" $p)}}
            {{Global "ParameterTypes" ("VkFlags" | Strings $pts | JoinWith "\n") }}
          {{else}}
            {{Global "ParameterTypes" (print (Macro "BaseType" $p) | Strings $pts | JoinWith "\n") }}
          {{end}}
        {{end}}
      {{end}}
    {{end}}
  {{end}}

  {{/* Now we add all the fields used by these types */}}
  {{$all_types := (Global "ParameterTypes") | SplitEOL}}
  {{range $t := $all_types}}
    {{range $c := $.Classes}}
      {{if eq $c.Name $t}}
        {{range $f := $c.Fields}}
          {{$p := $f.Type}}
          {{$pts := (Global "ParameterTypes")}}
          {{Global "ParameterTypes" (print (Macro "BaseType" $p) | Strings $pts | JoinWith "\n") }}
        {{end}}
      {{end}}
    {{end}}
  {{end}}

  {{/* We now remove duplicates by setting a global var to 0 for each type and checking if it's non-zero before emitting */}}
  {{$all_types := (Global "ParameterTypes") | SplitEOL}}
  {{range $c := $all_types}}
    {{Global $c 0}}
  {{end}}

  {{range $t := $all_types}}
    {{if eq (Global $t) 0}}
      {{Global $t 1}}
      {{range $c := $.Classes}}
        {{if eq $c.Name $t}}
          {{$pts := (Global "UniqueParameterTypes")}}
          {{Global "UniqueParameterTypes" ($t | Strings $pts | JoinWith "\n")}}
        {{end}}
      {{end}}
    {{end}}
  {{end}}
{{end}}


{{/*
  Defines the ostream override for referenced parameter types.  These are
  helpers used to print the details of parameters pass to the function.
*/}}
{{define "DefineRecorderParameterPrinters"}}
  {{Macro "GetUsedParameterTypesRecursive" $}}

  {{$all_types := (Global "UniqueParameterTypes") | SplitEOL}}

  {{range $t := $all_types}}
    {{range $c := $.Classes}}
      {{if eq $c.Name $t}}
      std::ostream& operator << (std::ostream& os, const {{$t}} &a);
      {{end}}
    {{end}}
  {{end}}
¶
  {{range $t := $all_types}}
    {{range $c := $.Classes}}
      {{if eq $c.Name $t}}
        {{Template "DefineRecorderParameterPrinter" $c}}
        ¶
      {{end}}
    {{end}}
  {{end}}
{{end}}


{{/*
  Defines the CopyArray template specializations for referenced parameter types.
*/}}
{{define "DefineRecorderArrayCopies"}}
  {{Macro "GetUsedParameterTypes" $}}

  {{$all_types := (Global "UniqueParameterTypes") | SplitEOL}}

  {{range $t := $all_types}}
    {{range $c := $.Classes}}
      {{if eq $c.Name $t}}
        {{Template "DefineRecorderArrayCopy" $c}}
        ¶
      {{end}}
    {{end}}
  {{end}}
{{end}}


{{define "DeclareCommandTracking"}}
  void TrackPre{{Macro "CmdNameNoVk" $}}({{Template "C++.CallParameters" $}});
  void TrackPost{{Macro "CmdNameNoVk" $}}({{Template "C++.CallParameters" $}});
{{end}}


{{define "DefineCommandTracking"}}
  {{AssertType $ "Function"}}
  void CommandTracker::TrackPre{{Macro "CmdNameNoVk" $}}({{Template "C++.CallParameters" $}})
  {
    Command cmd;
    cmd.type = Command::Type::k{{Macro "CmdNameNoVkNoCmd" $}};
    cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
    cmd.parameters = recorder_.Record{{Macro "CmdNameNoVk" $}}({{Template "C++.CallArguments" $}});
    commands_.push_back(cmd);
  }
  ¶
  void CommandTracker::TrackPost{{Macro "CmdNameNoVk" $}}({{Template "C++.CallParameters" $}})
  {
    assert(commands_.back().type == Command::Type::k{{Macro "CmdNameNoVkNoCmd" $}});
  }
  ¶
{{end}}


{{define "DeclareCommandTrackerPrintParameters"}}
  void Print{{Macro "CmdNameNoVk" $}}(std::ostream &os, const Command &cmd, const std::string& indent);
{{end}}

{{define "DefineCommandTrackerPrintParameters"}}
  void CommandTracker::Print{{Macro "CmdNameNoVk" $}}(std::ostream &os, const Command &cmd, const std::string& indent)
  {
    if (cmd.parameters) {
      auto args = reinterpret_cast<{{Template "DefineCommandArgStructName" $}} *>(cmd.parameters);
      recorder_.Print{{Macro "CmdNameNoVk" $}}Args(os, *args, indent);
    }
  }
  ¶
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits unwrapped member function declarations
-------------------------------------------------------------------------------
*/}}
{{define "DeclareUnwrappedInterceptFunction"}}
  {{$nameNoVk := Macro "CmdNameNoVk" $}}
  {{$.Return.Type}} Pre{{$nameNoVk}}(VkCommandBuffer wrappedCommandBuffer, {{Template "C++.CallParameters" $}});
  {{if not (IsVoid $.Return.Type)}}
  {{$.Return.Type}} Post{{$nameNoVk}}(VkCommandBuffer wrappedCommandBuffer, {{Template "C++.CallParameters" $ | Strings (Macro "ReturnParameter" $) | JoinWith ", " }});
  {{else}}
  {{$.Return.Type}} Post{{$nameNoVk}}(VkCommandBuffer wrappedCommandBuffer, {{Template "C++.CallParameters" $}});
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits member function declaration for the interceptor
-------------------------------------------------------------------------------
*/}}
{{define "DeclareGfrInterceptFunction"}}
  {{$nameNoVk := Macro "CmdNameNoVk" $}}
  {{if (Macro "IsPreInterceptedCommand" $)}}
    virtual {{$.Return.Type}} Pre{{$nameNoVk}}({{Template "WrappedCallParameters" $}}) final override;
  {{end}}
  {{if (Macro "IsPostInterceptedCommand" $)}}
    {{if not (IsVoid $.Return.Type)}}
    virtual {{$.Return.Type}} Post{{$nameNoVk}}({{Template "WrappedCallParameters" $ | Strings (Macro "ReturnParameter" $) | JoinWith ", " }}) final override;
    {{else}}
    virtual {{$.Return.Type}} Post{{$nameNoVk}}({{Template "WrappedCallParameters" $ }}) final override;
    {{end}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the GfrContext implementation of pre & post calls
-------------------------------------------------------------------------------
*/}}
{{define "DefineGfrInterceptFunction"}}
  {{$name := Macro "CmdName" $}}
  {{$nameNoVk := Macro "CmdNameNoVk" $}}
  {{$nameNoVkNoCmd := Macro "CmdNameNoVkNoCmd" $}}
  {{if (Macro "IsPreInterceptedCommand" $)}}
¶
    {{$.Return.Type}} GfrContext::Pre{{$nameNoVk}}({{Template "WrappedCallParameters" $}})
    {
      {{Template "UnwrapObjects" $}}
      {{if not (IsVoid $.Return.Type)}}return §{{end}}
      commandBuffer->custom_data->Pre{{$nameNoVk}}((VkCommandBuffer)commandBuffer, {{Macro "UnwrappedCallArguments" $ }});
    }
  {{end}}

  {{if (Macro "IsPostInterceptedCommand" $)}}
¶
    {{if not (IsVoid $.Return.Type)}}
    {{$.Return.Type}} GfrContext::Post{{$nameNoVk}}({{Template "WrappedCallParameters" $ | Strings (Macro "ReturnParameter" $) | JoinWith ", " }})
    {{else}}
    {{$.Return.Type}} GfrContext::Post{{$nameNoVk}}({{Template "WrappedCallParameters" $}})
    {{end}}
    {
      {{Template "UnwrapObjects" $}}
      {{if not (IsVoid $.Return.Type)}}
      return commandBuffer->custom_data->Post{{$nameNoVk}}((VkCommandBuffer)commandBuffer, {{Macro "UnwrappedCallArguments" $}}, result);
      {{else}}
      commandBuffer->custom_data->Post{{$nameNoVk}}((VkCommandBuffer)commandBuffer, {{Macro "UnwrappedCallArguments" $}});
      {{end}}
    }
  {{end}}
{{end}}


{{/*
------------------------------------------------------------------------------
  Returns true if a function should be instrumented always
------------------------------------------------------------------------------
*/}}
{{define "IsFunctionInstrumented"}}
  {{AssertType $ "Function"}}
  {{$filters := Strings (Macro "DefaultInstrumentedFunctions") | SplitEOL}}
  {{range $f := $filters}}
    {{if eq $.Name $f}}true{{end}}
  {{end}}
{{end}}


{{/*
------------------------------------------------------------------------------
  Emits a check to determine if a command should be instrumented
------------------------------------------------------------------------------
*/}}
{{/* TODO(aellem) make this a mask, not a boolean? */}}
{{define "InstrumentationTest"}}
  {{AssertType $ "Function"}}
  if ({{if not (Macro "IsFunctionInstrumented" $)}}instrument_all_commands_{{else}}true{{end}})
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the CommandBuffer tracking implementation of pre & post calls
-------------------------------------------------------------------------------
*/}}
{{define "DefineCommandBufferInterceptFunction"}}
  {{AssertType $ "Function"}}
  {{$name := Macro "CmdName" $}}
  {{$nameNoVk := Macro "CmdNameNoVk" $}}
¶
  {{$.Return.Type}} CommandBuffer::Pre{{$nameNoVk}}(VkCommandBuffer wrappedCommandBuffer, {{Template "C++.CallParameters" $}})
  {
    tracker_.TrackPre{{$nameNoVk}}({{Macro "C++.CallArguments" $ | Strings | Replace "commandBuffer" "wrappedCommandBuffer" | Replace "wrappedCommandBufferCount" "commandBufferCount" }});
    {{Template "InstrumentationTest" $}} {
      WriteBeginCommandExecutionMarker(tracker_.GetCommands().back().id);
    }
  }
¶
  {{if not (IsVoid $.Return.Type)}}
  {{$.Return.Type}} CommandBuffer::Post{{$nameNoVk}}(VkCommandBuffer wrappedCommandBuffer, {{Template "C++.CallParameters" $}})
  {{else}}
  {{$.Return.Type}} CommandBuffer::Post{{$nameNoVk}}(VkCommandBuffer wrappedCommandBuffer, {{Template "C++.CallParameters" $}})
  {{end}}
  {
    tracker_.TrackPost{{$nameNoVk}}({{Macro "C++.CallArguments" $ | Strings | Replace "commandBuffer" "wrappedCommandBuffer" | Replace "wrappedCommandBufferCount" "commandBufferCount" }});
    {{Template "InstrumentationTest" $}} {
      WriteEndCommandExecutionMarker(tracker_.GetCommands().back().id);
    }
  }
{{end}}
